	&FULLSCAN = 1	
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	digits = '0123456789'
	symbols = "<=>\+-*/^-,:.;_()[]'"
	everything = ((letters digits) symbols)
	logicalvalue = 'true' | 'false' 
	relationalop = '>=' | '<=' | '\=' | '<' | '>' | '=' 
	arithmeticop = '+' | '-' | '*' | '/' | '^'
	logicop = 'and' | 'or' | '==' | 'not' | '->'
	separator = ',' | ':=' | '.' | ';' | ':' | '_' | 'step' | 'while' | 'until' | 'comment'
	bracket = '(' | ')' | '[' | ']' | "'" | 'begin' | 'end'
	types = 'real' | 'integer' | 'Boolean'
	optspace = SPAN(' ') | ''
;*Using the failure pattern, enforce some type rules

;*COMMENTS
	COMMENT1 = ';' optspace 'comment' ARB ';'
	COMMENT2 = 'begin' SPAN(' ') 'comment' ARB ';'
	COMMENT3 = 'end' SPAN(' ') 'comment' (ARB 'end' | ARB ';' | ARB 'else') FAIL
	COMMENT = COMMENT1 | COMMENT2 | COMMENT3
;*IDENTIFIER/NORMAL VARIABLE
	ID1 = @N POS(*N) ANY(letters)
	ID2 = SPAN(letters digits) | ''
	IDENTIFIER = ID1 ID2
;*NUMBER
	NUM1 = (ANY('+-') | '') SPAN(digits)
	NUM2 = '.' SPAN(DIGITS)
	NUMBER = NUM1 (NUM2 | '')
	UNSIGNEDNUM = SPAN(DIGITS) ('.' SPAN(DIGITS) | '')
;*ARRAY
	SIMPLEVAR = IDENTIFIER
	ARRAYITEM = *ARITHMETICEXP | *SUBSCRIPTEDVAR
	SUBLIST = '[' ARRAYITEM ARBNO(',' ARRAYITEM) ']' 
	SUBSCRIPTEDVAR = SIMPLEVAR SUBLIST
	VARIABLE = SUBSCRIPTEDVAR | SIMPLEVAR
;*FUNCTIONCALL
	STRING = "'" SPAN(((LETTERS DIGITS) '<=>\+-*/^-,:.;_()[] ')) "'"
	PARAM = *ARITHMETICEXP | SUBSCRIPTEDVAR | IDENTIFIER | STRING
	PARAMDELIMITER = ',' | ')' SPAN(LETTERS) ':' optspace '('
	PARAMLIST = PARAM ARBNO(PARAMDELIMITER PARAM)
	PARAMPART =  '(' PARAMLIST ')' 
	FUNCTCALL = IDENTIFIER optspace PARAMPART | IDENTIFIER SPAN(' ') (';' | 'end')
;*BOOLEANEXP - problem with recognizing and,or in combined expressions
	RELATION = *ARITHMETICEXP (SPAN(' ') | '') relationalop (SPAN(' ') | '') *ARITHMETICEXP
	BOOLPRIMARY = (RELATION | FUNCTCALL |  '(' *BOOLEANEXP ')' | logicalvalue | SUBSCRIPTEDVAR | SIMPLEVAR)
	BOOLSECOND = ('not' SPAN(' ') | '') BOOLPRIMARY
	BOOLFACTOR1 = *(X ((SPAN(' ') 'and' SPAN(' ') *BOOLFACTOR) | ''))
	BOOLFACTOR = BOOLSECOND $ X EVAL(BOOLFACTOR1)
	BOOLTERM1 = *(X ((SPAN(' ') 'or' SPAN(' ') *BOOLTERM) | ''))
	BOOLTERM = BOOLFACTOR $ X EVAL(BOOLTERM1)
	IMPL1 = *(X (((SPAN(' ') | '') '->' (SPAN(' ') | '') *IMPLICATION) | ''))
	IMPLICATION = BOOLTERM $ X EVAL(IMPL1)
	SIMPLEBOOL1 = *(X (((SPAN(' ') | '') '==' (SPAN(' ') | '') *SIMPLEBOOL) | ''))
	SIMPLEBOOL = IMPLICATION $ X EVAL(SIMPLEBOOL1)
	ELSEBOOL = 'else' SPAN(' ') *BOOLEANEXP
	BOOLEANEXP = *IFCLAUSE SPAN(' ') SIMPLEBOOL SPAN(' ') ELSEBOOL | SIMPLEBOOL
;*ARITHMETICEXP 
	PRIMARY = FUNCTCALL | SUBSCRIPTEDVAR | IDENTIFIER | UNSIGNEDNUM | '(' *SIMPLEARITHEXP ')'
	FACTOR1 = *(X (('^' *FACTOR) | ''))
	FACTOR = PRIMARY $ X EVAL(FACTOR1) ;*ARBNO('^' PRIMARY) RPOS(0)
	TERM1 = *(X ((ANY('*/') *TERM) | ''))
	TERM = FACTOR $ X EVAL(TERM1)  ;*ARBNO(ANY('*/') FACTOR) RPOS(0)
	SIMPLEARITHEXP1 = *(X ((ANY('+-') *SIMPLEARITHEXP) | ''))
	SIMPLEARITHEXP = (ANY('+-') | '') TERM $ X EVAL(SIMPLEARITHEXP1)
	ARITHELSE = 'else' SPAN(' ') *ARITHMETICEXP
	ARITHMETICEXP = *IFCLAUSE SPAN(' ') SIMPLEARITHEXP SPAN(' ') ARITHELSE | *SIMPLEARITHEXP
;*DESIGNATIONEXP
	LABEL = IDENTIFIER | UNSIGNEDNUM
	SWITCHDES = IDENTIFIER SUBLIST
	SIMPLEDESEXP = SWITCHDES | LABEL | '(' *DESIGNEXP ')'
	DESIGNELSE = 'else' SPAN(' ') *DESIGNEXP
	DESIGNEXP = *IFCLAUSE SPAN(' ') SIMPLEDESEXP SPAN(' ') DESIGNELSE | SIMPLEDESEXP
;*GENERAL EXPRESSION
	EXPRESSION = ARITHMETICEXP | BOOLEANEXP | DESIGNEXP
;*STATEMENTS -------------------------------------------------
;*ASSIGNMENT STATEMENT
	LEFTPART = VARIABLE (SPAN(' ') | '') ':='
	LEFTPARTLIST1 = *(X ((SPAN(' ') | '') *LEFTPARTLIST | ''))
	LEFTPARTLIST = LEFTPART $ X EVAL(LEFTPARTLIST1)
	ASSIGNSTATEMENT = LEFTPARTLIST (SPAN(' ') | '') (ARITHMETICEXP | BOOLEANEXP)
;*GO TO STATEMENT
	GOTOSTATEMENT = 'go to' SPAN(' ') DESIGNEXP
;*DUMMY STATEMENT
	DUMMYSTATEMENT = SPAN(' ') | ''
;*COMPOUND STATEMENTS AND BLOCKS
	UNLABELBASICSTATEMENT = ASSIGNSTATEMENT | GOTOSTATEMENT | FUNCTCALL | DUMMYSTATEMENT 
	MULTLABELS1 = *(X ((LABEL ':' optspace *MULTLABELS) | ''))
	MULTLABELS = (LABEL ':' optspace $ X EVAL(MULTLABELS1) | '')
	BASICSTAT =  MULTLABELS UNLABELBASICSTATEMENT
	UNCONDSTAT =  *COMPSTATEMENT | *FORSTATEMENT | *BLOCK | BASICSTAT
	STATEMENT = UNCONDSTAT | *CONDSTAT
	COMPTAIL1 = *(X (optspace *COMPOUNDTAIL))
	COMPOUNDTAIL = STATEMENT (SPAN(' ') 'end' | optspace ';' $ X EVAL(COMPTAIL1))
	BLOCKHEAD1 = *(X ((optspace *BLOCKHEAD2) | ''))
	BLOCKHEAD2 = *DECLARATION optspace ';' $ X EVAL(BLOCKHEAD1)
	BLOCKHEAD = 'begin' SPAN(' ') (*DECLARATION optspace ';') $ X EVAL(BLOCKHEAD1)
	UNLABELCOM = 'begin' SPAN(' ') COMPOUNDTAIL
	UNLABELBLOCK = BLOCKHEAD optspace COMPOUNDTAIL
	COMPSTATEMENT = MULTLABELS UNLABELCOM
	BLOCK = MULTLABELS UNLABELBLOCK
;*CONDITIONAL STATEMENT
	IFCLAUSE = 'if' SPAN(' ') BOOLEANEXP SPAN(' ') 'then'
	IFSTATEMENT = (IFCLAUSE SPAN(' ') UNCONDSTAT)
	CONDELSE = 'else' SPAN(' ') STATEMENT
	CONDSTAT = IFSTATEMENT (SPAN(' ') CONDELSE | '')
;*FOR STATEMENT
	FORLISTELEMENT1 = ARITHMETICEXP SPAN(' ') 'step' SPAN(' ') ARITHMETICEXP SPAN(' ') 'until' SPAN(' ') ARITHMETICEXP
	FORLISTELEMENT2 = ARITHMETICEXP SPAN(' ') 'while' SPAN(' ') BOOLEANEXP
	FORLISTELEMENT = FORLISTELEMENT2 | FORLISTELEMENT1 | ARITHMETICEXP 
	FORLIST1 = *(X ((optspace ',' optspace *FORLIST) | '')) 
	FORLIST = FORLISTELEMENT $ X EVAL(FORLIST1)
	FORCLAUSE = 'for' SPAN(' ') VARIABLE optspace ':=' optspace FORLIST SPAN(' ') 'do'
	FORSTATEMENT = MULTLABELS FORCLAUSE SPAN(' ') STATEMENT
;*DECLARATIONS-------------------------------------------	
;*TYPE DECLARATIONS
	TYPELIST1 = *(X ((optspace ',' optspace *TYPELIST) | ''))
	TYPELIST = IDENTIFIER $ X EVAL(TYPELIST1)
	LOCALTYPE = ('own' SPAN(' ') | '') types
	TYPEDEC = LOCALTYPE SPAN(' ') TYPELIST
;*ARRAY DECLARATIONS
	BOUNDPAIR = ARITHMETICEXP ':' ARITHMETICEXP
	BOUNDPAIRLIST1 = *(X ((optspace ',' optspace *BOUNDPAIR) | ''))
	BOUNDPAIRLIST = BOUNDPAIR $ X EVAL(BOUNDPAIRLIST1)
	ARRAYSEG1 = *(X ((optspace ',' optspace *ARRAYSEG) | ''))
	ARRAYSEG = IDENTIFIER ('[' BOUNDPAIRLIST ']' | '') $ X EVAL(ARRAYSEG1)
	ARRAYLIST1 = *(X ((optspace ',' optspace *ARRAYLIST) | ''))
	ARRAYLIST = ARRAYSEG $ X EVAL(ARRAYLIST1)
	ARRAYDEC = (LOCALTYPE SPAN(' ') | '') 'array' SPAN(' ') ARRAYLIST
;*SWITCH DECLARATIONS
	SWITCHLIST1 = *(X ((optspace ',' optspace *SWITCHLIST) | ''))
	SWITCHLIST = DESIGNEXP $ X EVAL(SWITCHLIST1)
	SWITCHDEC = 'switch' SPAN(' ') IDENTIFIER optspace ':=' optspace SWITCHLIST
;*PROCEDURE DECLARATIONS
	FORMALPARAMPART = PARAMPART | ''
	IDLIST1 = *(X ((optspace ',' optspace *IDLIST) | ''))
	IDLIST = IDENTIFIER $ X EVAL(IDLIST1)
	VALUEPART = 'value' SPAN(' ') IDLIST optspace ';' | ''
	SPECIFIER = types (SPAN(' ') ('array' | 'procedure') | '') | 'string' | 'label' | 'switch' | 'procedure' | 'array'
	SPECPART1 = *(X ((optspace *SPECPART) | ''))
	SPECPART = SPECIFIER SPAN(' ') IDLIST optspace ';' $ X EVAL(SPECPART1) | ''
	PROCHEAD = VALUEPART SPAN(' ') SPECPART | IDENTIFIER FORMALPARAMPART
	PROCBODY = 
	PROCEDUREDEC = (types SPAN(' ') | '') 'procedure' SPAN(' ') PROCHEAD optspace ';'
;*GENERAL DECLARATION
	DECLARATION = PROCEDUREDEC | SWITCHDEC | ARRAYDEC | TYPEDEC

TEST	originalline = input	:F(GOOD)
	originalline block . output =	:(TEST)
	PROGRAM = PROGRAM ORIGINALLINE	:(TEST)
	
CHECK	program BLOCK . output =	:F(BAD)S(GOOD)

BAD	output = 'No'	:(END)
GOOD	output = 'Yes'	:(END)

END
