	&trim = 1	
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	digits = '0123456789'
	symbols = "<=>\+-*/^-,:.;_()[]'"
	logicalvalue = 'true' | 'false' 
	relationalop = '<' | '<=' | '>' | '>=' | '=' | '\='
	arithmeticop = '+' | '-' | '*' | '/' | '^'
	logicop = 'and' | 'or' | '==' | 'not' | '->'
	separator = ',' | ':=' | '.' | ';' | ':' | '_' | 'step' | 'while' | 'until' | 'comment'
	bracket = '(' | ')' | '[' | ']' | "'" | 'begin' | 'end'
	types = 'real' | 'integer' | 'Boolean'
	specificator = 'string' | 'label' | 'value'
	
	ct = 0	 ;*begin statements that haven't been closed yet	
;*Not all of those should be doing GETWORDS; you have to check for operators as well	
	
	DEFINE('IDENTIFIER(line)')
	DEFINE('NUMBER(line)')
	;*Description: Checks the symbol after a variable for a [ to determine whether to continue
	;* as an array or not.
	DEFINE('ARRAYSIGN(line)')
	DEFINE('BEGINBLOCK(line)')
	DEFINE('ARITHMETICEXP(line)')
	DEFINE('COMMENT(actualline)')
	DEFINE('DECLARATION(actualline)')
	DEFINE('PROCEDURE(actualline)')

NEXTL	originalline = input	:f(GOOD)S(GETSYMBOL)

;* Gets the individual words of the line
GETSYMBOL
	originalline (SPAN(letters digits) | ANY(symbols) | ' ') . symbol =	:f(NEXTL)
	IDENT(symbol,';')	:S(CHECK)
	actualline = actualline symbol	:(GETSYMBOL)

CHECK	COMMENT(actualline)	:S(GETSYMBOL)
	PROCEDURE(actualline)	:S(GETSYMBOL)
	DECLARATION(actualline)	:S(DECLAR)F(NOTDECLAR)

PROCEDURE
	output = 'In Procedure'
	templine = actualline
	templine (SPAN(letters)) . check =
	IDENT(check,'procedure')	:s(PROC1)
	IDENT(check,types)	:s(PROC0)F(freturn)
PROC0	templine (SPAN(letters)) . check =	:f(BAD)
	IDENT(check,'procedure')	:f(BAD)S(PROC1)
PROC1	templine = actualline
	VALUEPART1 = 'value' SPAN(' ')
	VALUEPART2 = VALUEPART1 (SPAN((letters digits) (', ')))
	SPECIFIER = ('string' | types | 'array' | 'label' | 'switch' | (types (array | procedure)))
	;*Check the current line's stuff for being correct before moving to PROC2
	actualline = ''
PROC2	originalline (SPAN(letters digits) | ANY(symbols) | ' ') . symbol =	:f(PROC3)
	IDENT(symbol,';')	:S(PROC4)
	;*IDENT(symbol,'end')	:S(PROC4)
	actualline = actualline symbol	:(PROC2)
PROC3	originalline = input	:s(PROC2)f(return)
PROC4	COMMENT(actualline)	:S(PROC5)
	DECLARATION(actualline)	:(PROC5)
	templine = actualline
	templine VALUEPART2 =	:S(PROC5)
	templine = actualline
	templine SPECIFIER =	:(PROC5)
PROC5	output = actualline
	actualline = ''	:(PROC2)
	

DECLARATION
	templine = actualline
DECLARTYPE
	OWN = ('own' | '') ' '
	TYPEDEC = OWN types
	templine TYPEDEC =	:s(return)f(DECLARARRAY) ;*on S, check list of items
DECLARARRAY
	templine = actualline
	ARRAYDEC = (TYPEDEC | '') 'array'
	templine ARRAYDEC =	:s(return)f(DECLARSWITCH)
DECLARSWITCH
	templine = actualline
	SWITCHDEC1 = 'switch' SPAN(' ')
	SWITCHDEC2 = SWITCHDEC1 SPAN(letters)
	SWITCHDEC3 = SWITCHDEC2 (SPAN(' ') ':=')
	templine SWITCHDEC3 =	:S(RETURN)F(freturn)
	
DECLAR	output = 'A declaration'
	output = actualline
	actualline = ''	:(GETSYMBOL)
NOTDECLAR	output = 'Not a declaration'
	output = actualline
	actualline = ''	:(GETSYMBOL)

COMMENT	templine = actualline
	templine (SPAN(letters)) . check =
	IDENT(check,'comment')	:s(COMMENT1)f(freturn)
COMMENT1	actualline = ''	:(return)

BAD	output = 'No'	:(END)
GOOD	output = 'Yes'	:(END)

END
