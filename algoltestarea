	&FULLSCAN = 1	
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	digits = '0123456789'
	symbols = "<=>\+-*/^-,:.;_()[]'"
	everything = ((letters digits) symbols)
	logicalvalue = 'true' | 'false' 
	relationalop = '>=' | '<=' | '\=' | '<' | '>' | '=' 
	arithmeticop = '+' | '-' | '*' | '/' | '^'
	logicop = 'and' | 'or' | '==' | 'not' | '->'
	separator = ',' | ':=' | '.' | ';' | ':' | '_' | 'step' | 'while' | 'until' | 'comment'
	bracket = '(' | ')' | '[' | ']' | "'" | 'begin' | 'end'
	types = 'real' | 'integer' | 'Boolean'
	optspace = SPAN(' ') | ''
;*Using the failure pattern, enforce some type rules

;*COMMENTS
	COMMENT1 = optspace 'comment' BREAK(';') ';' ;* ;
	COMMENT2 = 'comment' BREAK(';') ';'  ;* begin
	COMMENT3 = SPAN(' ') 'comment' (ARB 'end' | ARB ';' | ARB 'else') ;* end
	COMMENT = COMMENT1 | COMMENT2 | COMMENT3
;*IDENTIFIER/NORMAL VARIABLE
	ID1 = @N POS(*N) ANY(letters)
	ID2 = SPAN(letters digits) | ''
	IDENTIFIER = ID1 ID2
;*NUMBER
	NUM1 = (ANY('+-') | '') SPAN(digits)
	NUM2 = '.' SPAN(DIGITS)
	NUMBER = NUM1 (NUM2 | '')
	UNSIGNEDNUM = SPAN(DIGITS) ('.' SPAN(DIGITS) | '')
;*ARRAY
	SIMPLEVAR = IDENTIFIER
	ARRAYITEM = *ARITHMETICEXP | *SUBSCRIPTEDVAR
	SUBLIST1 = *(X ((optspace ',' optspace *SUBLIST2) | ''))
	SUBLIST2 = ARRAYITEM $ X EVAL(SUBLIST1)
	SUBLIST = '[' ARRAYITEM $ X EVAL(SUBLIST1) ']'
	SUBSCRIPTEDVAR = SIMPLEVAR SUBLIST
	VARIABLE = SUBSCRIPTEDVAR | SIMPLEVAR
;*FUNCTIONCALL
	STRING = "'" SPAN(((LETTERS DIGITS) '<=>\+-*/^-,:.;_()[] ')) "'"
	PARAM = *ARITHMETICEXP | SUBSCRIPTEDVAR | IDENTIFIER | STRING
	PARAMDELIMITER = ',' | ')' optspace SPAN(LETTERS) optspace ':' optspace '('
	PARAMLIST1 = *(X ((optspace PARAMDELIMITER optspace *PARAMLIST) | ''))
	PARAMLIST = PARAM $ X EVAL(PARAMLIST1)
	PARAMPART =  '(' PARAMLIST ')' 
	FUNCTCALL = IDENTIFIER optspace PARAMPART | IDENTIFIER (optspace ';' (COMMENT1 | '') | SPAN(' ') 'end' (COMMENT3  | ''))
;*BOOLEANEXP 
	RELATION = *ARITHMETICEXP (SPAN(' ') | '') relationalop (SPAN(' ') | '') *ARITHMETICEXP
	BOOLPRIMARY = (RELATION | FUNCTCALL |  '(' *BOOLEANEXP ')' | logicalvalue | SUBSCRIPTEDVAR | SIMPLEVAR)
	BOOLSECOND = ('not' SPAN(' ') | '') BOOLPRIMARY
	BOOLFACTOR1 = *(X ((SPAN(' ') 'and' SPAN(' ') *BOOLFACTOR) | ''))
	BOOLFACTOR = BOOLSECOND $ X EVAL(BOOLFACTOR1)
	BOOLTERM1 = *(X ((SPAN(' ') 'or' SPAN(' ') *BOOLTERM) | ''))
	BOOLTERM = BOOLFACTOR $ X EVAL(BOOLTERM1)
	IMPL1 = *(X (((SPAN(' ') | '') '->' (SPAN(' ') | '') *IMPLICATION) | ''))
	IMPLICATION = BOOLTERM $ X EVAL(IMPL1)
	SIMPLEBOOL1 = *(X (((SPAN(' ') | '') '==' (SPAN(' ') | '') *SIMPLEBOOL) | ''))
	SIMPLEBOOL = IMPLICATION $ X EVAL(SIMPLEBOOL1)
	ELSEBOOL = 'else' SPAN(' ') *BOOLEANEXP
	BOOLEANEXP = *IFCLAUSE SPAN(' ') SIMPLEBOOL SPAN(' ') ELSEBOOL | SIMPLEBOOL
;*ARITHMETICEXP 
	PRIMARY = FUNCTCALL | SUBSCRIPTEDVAR | IDENTIFIER | UNSIGNEDNUM | '(' *SIMPLEARITHEXP ')'
	FACTOR1 = *(X ((optspace '^' optspace *FACTOR) | ''))
	FACTOR = PRIMARY $ X EVAL(FACTOR1)
	TERM1 = *(X ((optspace ANY('*/') optspace *TERM) | ''))
	TERM = FACTOR $ X EVAL(TERM1)
	SIMPLEARITHEXP1 = *(X ((optspace ANY('+-') optspace *SIMPLEARITHEXP) | ''))
	SIMPLEARITHEXP = (ANY('+-') | '') TERM $ X EVAL(SIMPLEARITHEXP1)
	ARITHELSE = 'else' SPAN(' ') *ARITHMETICEXP
	ARITHMETICEXP = *IFCLAUSE SPAN(' ') SIMPLEARITHEXP SPAN(' ') ARITHELSE | SIMPLEARITHEXP
;*DESIGNATIONEXP
	LABEL = IDENTIFIER | UNSIGNEDNUM
	SWITCHDES = IDENTIFIER SUBLIST
	SIMPLEDESEXP = SWITCHDES | LABEL | '(' *DESIGNEXP ')'
	DESIGNELSE = 'else' SPAN(' ') *DESIGNEXP
	DESIGNEXP = *IFCLAUSE SPAN(' ') SIMPLEDESEXP SPAN(' ') DESIGNELSE | SIMPLEDESEXP
;*GENERAL EXPRESSION
	EXPRESSION = ARITHMETICEXP | BOOLEANEXP | DESIGNEXP
;*STATEMENTS -------------------------------------------------
;*ASSIGNMENT STATEMENT
	LEFTPART = VARIABLE (SPAN(' ') | '') ':='
	LEFTPARTLIST1 = *(X ((SPAN(' ') | '') *LEFTPARTLIST | ''))
	LEFTPARTLIST = LEFTPART $ X EVAL(LEFTPARTLIST1)
	ASSIGNSTATEMENT = LEFTPARTLIST (SPAN(' ') | '') (ARITHMETICEXP | BOOLEANEXP)
;*GO TO STATEMENT
	GOTOSTATEMENT = 'go to' SPAN(' ') DESIGNEXP
;*DUMMY STATEMENT
	DUMMYSTATEMENT = SPAN(' ') (';' | 'end')
;*COMPOUND STATEMENTS AND BLOCKS
	UNLABELBASICSTATEMENT = ASSIGNSTATEMENT | GOTOSTATEMENT | FUNCTCALL | DUMMYSTATEMENT 
	MULTLABELS1 = *(X ((LABEL ':' optspace *MULTLABELS) | ''))
	MULTLABELS = (LABEL ':' optspace $ X EVAL(MULTLABELS1) | '')
	BASICSTAT =  MULTLABELS UNLABELBASICSTATEMENT
	UNCONDSTAT =  *COMPSTATEMENT | *BLOCK | *FORSTATEMENT | BASICSTAT
	STATEMENT = UNCONDSTAT | *CONDSTAT
	BEGINCOMMENT = COMMENT2 $ X EVAL(CTAILNEXT)
	CTAILNEXT = *(X ((optspace *CTAIL) | ''))
	;*CTAILEND = *(X ((SPAN(' ') IDENTIFIER SPAN(' ') *CTAIL) | ''))
	CTAILEND1 = *(X (*CTAILEND | ''))
	CTAILEND = optspace (';' | 'else' | 'end' $ X EVAL(CTAILEND1) | LABEL $ X EVAL(CTAILEND1) | '')
	CTAIL = STATEMENT (optspace ';' $ X EVAL(CTAILNEXT) | SPAN(' ') 'end')
	COMPOUNDTAIL = BEGINCOMMENT | CTAIL CTAILEND
	BLOCKHEAD1 = *(X ((optspace *BLOCKHEAD2) | ''))
	BLOCKHEAD2 = *DECLARATION optspace ';' $ X EVAL(BLOCKHEAD1)
	BLOCKHEAD = 'begin' SPAN(' ') ((*DECLARATION optspace ';') | COMMENT2) $ X EVAL(BLOCKHEAD1)
	UNLABELCOM = 'begin' SPAN(' ') COMPOUNDTAIL
	UNLABELBLOCK = BLOCKHEAD optspace COMPOUNDTAIL
	COMPSTATEMENT = MULTLABELS UNLABELCOM
	BLOCK = MULTLABELS UNLABELBLOCK 
;*CONDITIONAL STATEMENT
	IFCLAUSE = 'if' SPAN(' ') BOOLEANEXP SPAN(' ') 'then'
	IFSTATEMENT = MULTLABELS IFCLAUSE SPAN(' ') UNCONDSTAT
	CONDELSE = 'else' SPAN(' ') STATEMENT
	CONDSTAT = IFSTATEMENT span(' ') condelse | IFSTATEMENT 
;*FOR STATEMENT
	FORLISTELEMENT1 = ARITHMETICEXP SPAN(' ') 'step' SPAN(' ') ARITHMETICEXP SPAN(' ') 'until' SPAN(' ') ARITHMETICEXP
	FORLISTELEMENT2 = ARITHMETICEXP SPAN(' ') 'while' SPAN(' ') BOOLEANEXP
	FORLISTELEMENT = FORLISTELEMENT2 | FORLISTELEMENT1 | ARITHMETICEXP 
	FORLIST1 = *(X ((optspace ',' optspace *FORLIST) | '')) 
	FORLIST = FORLISTELEMENT $ X EVAL(FORLIST1)
	FORCLAUSE = 'for' SPAN(' ') VARIABLE optspace ':=' optspace FORLIST SPAN(' ') 'do'
	FORSTATEMENT = MULTLABELS FORCLAUSE SPAN(' ') STATEMENT
;*DECLARATIONS-------------------------------------------	
;*TYPE DECLARATIONS
	TYPELIST1 = *(X ((optspace ',' optspace *TYPELIST) | ''))
	TYPELIST = IDENTIFIER $ X EVAL(TYPELIST1)
	LOCALTYPE = ('own' SPAN(' ') | '') types
	TYPEDEC = LOCALTYPE SPAN(' ') TYPELIST
;*ARRAY DECLARATIONS
	BOUNDPAIR = ARITHMETICEXP ':' ARITHMETICEXP
	BOUNDPAIRLIST1 = *(X ((optspace ',' optspace *BOUNDPAIR) | ''))
	BOUNDPAIRLIST = BOUNDPAIR $ X EVAL(BOUNDPAIRLIST1)
	ARRAYSEG1 = *(X ((optspace ',' optspace *ARRAYSEG) | ''))
	ARRAYSEG = IDENTIFIER ('[' BOUNDPAIRLIST ']' | '') $ X EVAL(ARRAYSEG1)
	ARRAYLIST1 = *(X ((optspace ',' optspace *ARRAYLIST) | ''))
	ARRAYLIST = ARRAYSEG $ X EVAL(ARRAYLIST1)
	ARRAYDEC = (LOCALTYPE SPAN(' ') | '') 'array' SPAN(' ') ARRAYLIST
;*SWITCH DECLARATIONS
	SWITCHLIST1 = *(X ((optspace ',' optspace *SWITCHLIST) | ''))
	SWITCHLIST = DESIGNEXP $ X EVAL(SWITCHLIST1)
	SWITCHDEC = 'switch' SPAN(' ') IDENTIFIER optspace ':=' optspace SWITCHLIST
;*PROCEDURE DECLARATIONS
	FORMALPARAMPART = PARAMPART | ''
	VALUEPART = 'value' SPAN(' ') TYPELIST optspace ';'
	SPECIFIER = types (SPAN(' ') ('array' | 'procedure') | '') | 'string' | 'label' | 'switch' | 'procedure' | 'array'
	SPECPART1 = *(X ((optspace *SPECPART) | ''))
	SPECPART = SPECIFIER SPAN(' ') TYPELIST optspace ';' $ X EVAL(SPECPART1)
	PROCHEAD = FUNCTCALL optspace ';' optspace (comment1 | '') optspace (VALUEPART | '') optspace (comment1 | '') optspace (SPECPART | '')
	PROCBODY = BLOCK | STATEMENT
	PROCEDUREDEC = (types SPAN(' ') | '') 'procedure' SPAN(' ') PROCHEAD optspace (comment1 | '')  optspace PROCBODY
;*GENERAL DECLARATION
	DECLARATION = PROCEDUREDEC | SWITCHDEC | ARRAYDEC | TYPEDEC

TEST	PROGRAM = PROGRAM ' '
	originalline = input	:F(CHECK)
	PROGRAM = PROGRAM ORIGINALLINE	:(TEST)
	
CHECK	t = TRIM(PROGRAM)
	t ' ' =
	ORIGSIZE = SIZE(t)	
	program block . newprog =
	newprog = TRIM(newprog)	
	output = ORIGSIZE
	output = t
	output = SIZE(newprog)
	output = newprog	
	IDENT(ORIGSIZE,SIZE(newprog))	:S(GOOD)F(BAD)
	

BAD	output = 'No'	:(END)
GOOD	output = 'Yes'	:(END)

END
