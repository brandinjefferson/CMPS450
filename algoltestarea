	&FULLSCAN = 1	
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	digits = '0123456789'
	symbols = "<=>\+-*/^-,:.;_()[]'"
	everything = ((letters digits) symbols)
	logicalvalue = 'true' | 'false' 
	relationalop = '<' | '<=' | '>' | '>=' | '=' | '\='
	arithmeticop = '+' | '-' | '*' | '/' | '^'
	logicop = 'and' | 'or' | '==' | 'not' | '->'
	separator = ',' | ':=' | '.' | ';' | ':' | '_' | 'step' | 'while' | 'until' | 'comment'
	bracket = '(' | ')' | '[' | ']' | "'" | 'begin' | 'end'
	types = 'real' | 'integer' | 'Boolean'
	specificator = 'string' | 'label' | 'value'
	LABEL = (NOTANY(' ') SPAN(letters)) ':'
	ct = 0
	beginct = 0	 ;*begin statements that haven't been closed yet	

;*IDENTIFIER/NORMAL VARIABLE
	ID1 = @N POS(*N) ANY(letters)
	ID2 = SPAN(letters digits) | ''
	IDENTIFIER = ID1 ID2
;*NUMBER
	NUM1 = (ANY('+-') | '') SPAN(digits)
	NUM2 = '.' SPAN(DIGITS)
	NUMBER = NUM1 (NUM2 | '')
	UNSIGNEDNUM = SPAN(DIGITS) ('.' SPAN(DIGITS) | '')
;*ARRAY
	SIMPLEVAR = IDENTIFIER
	ARRAYITEM = *ARITHMETICEXP | *SUBSCRIPTEDVAR
	SUBLIST = '[' ARRAYITEM ARBNO(',' ARRAYITEM) ']' 
	SUBSCRIPTEDVAR = SIMPLEVAR SUBLIST
;*FUNCTIONCALL
	STRING = "'" SPAN(((LETTERS DIGITS) '<=>\+-*/^-,:.;_()[] ')) "'"
	PARAM =  SUBSCRIPTEDVAR | IDENTIFIER | STRING | *ARITHMETICEXP
	;*PARAM = SPAN((letters digits) "+-/\=*^<>'")
	PARAMDELIMITER = ',' | ')' SPAN(LETTERS) ':('
	PARAMLIST = PARAM ARBNO(PARAMDELIMITER PARAM)
	ENDPARAM = (')' @N POS(*N) ANY('+-/*^ <>;=\,)]'))
	PARAM1 = ARB ENDPARAM @N 
	PARAMPART =  '(' PARAMLIST ')' 
	FUNCTCALL = IDENTIFIER PARAMPART | IDENTIFIER ' '
;*BOOLEANEXP
	RELATION = *ARITHMETICEXP (SPAN(' ') | '') relationalop (SPAN(' ') | '') *ARITHMETICEXP
	BOOLPRIMARY = (RELATION | FUNCTCALL |  '(' *BOOLEANEXP ')' | logicalvalue | SUBSCRIPTEDVAR | SIMPLEVAR)
	BOOLSECOND = ('not' SPAN(' ') | '') BOOLPRIMARY
	BOOLFACTOR1 = *(X ((SPAN(' ') 'and' SPAN(' ') *BOOLFACTOR) | ''))
	BOOLFACTOR = BOOLSECOND $ X EVAL(BOOLFACTOR1)
	BOOLTERM1 = *(X ((SPAN(' ') 'or' SPAN(' ') *BOOLTERM) | ''))
	BOOLTERM = BOOLFACTOR $ X EVAL(BOOLTERM1)
	IMPL1 = *(X (((SPAN(' ') | '') '->' (SPAN(' ') | '') *IMPLICATION) | ''))
	IMPLICATION = BOOLTERM $ X EVAL(IMPL1)
	SIMPLEBOOL1 = *(X (((SPAN(' ') | '') '==' (SPAN(' ') | '') *SIMPLEBOOL) | ''))
	SIMPLEBOOL = IMPLICATION $ X EVAL(SIMPLEBOOL1)
	BOOLEANEXP = SIMPLEBOOL ;* | IFCLAUSE SIMPLEBOOL SPAN(' ') 'else' SPAN(' ') BOOLEANEXP
;*ARITHMETICEXP 
	PRIMARY = FUNCTCALL | SUBSCRIPTEDVAR | IDENTIFIER | UNSIGNEDNUM | '(' *SIMPLEARITHEXP ')'
	FACTOR1 = *(X (('^' *FACTOR) | ''))
	FACTOR = PRIMARY $ X EVAL(FACTOR1) ;*ARBNO('^' PRIMARY) RPOS(0)
	TERM1 = *(X ((ANY('*/') *TERM) | ''))
	TERM = FACTOR $ X EVAL(TERM1)  ;*ARBNO(ANY('*/') FACTOR) RPOS(0)
	SIMPLEARITHEXP1 = *(X ((ANY('+-') *SIMPLEARITHEXP) | ''))
	SIMPLEARITHEXP = (ANY('+-') | '') TERM $ X EVAL(SIMPLEARITHEXP1)
	ARITHMETICEXP = SIMPLEARITHEXP  ;* | IFCLAUSE
;*DESIGNATIONEXP
	LABEL = IDENTIFIER | UNSIGNEDNUM
	SWITCHDES = IDENTIFIER SUBLIST
	SIMPLEDESEXP = SWITCHDES | LABEL | '(' *DESIGNEXP ')'
	DESIGNEXP = SIMPLEDESEXP ;* | IFCLAUSE SIMPLEDESEXP SPAN(' ') 'else' SPAN(' ') DESIGNEXP
		

TEST	originalline = input	:F(GOOD)
	originalline BOOLEANEXP . output =	:(TEST)
	
TEST1	originalline (SPAN(letters digits) | ANY(symbols) | SPAN(' ')) . symbol =	:F(TEST2)
	actualline = actualline symbol	:(TEST1)	
TEST2	

BAD	output = 'No'	:(END)
GOOD	output = 'Yes'	:(END)

END
