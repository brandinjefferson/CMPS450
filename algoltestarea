	&trim = 1	
	letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	digits = '0123456789'
	symbols = "<=>\+-*/^-,:.;_()[]'"
	logicalvalue = 'true' | 'false' 
	relationalop = '<' | '<=' | '>' | '>=' | '=' | '\='
	arithmeticop = '+' | '-' | '*' | '/' | '^'
	logicop = 'and' | 'or' | '==' | 'not' | '->'
	separator = ',' | ':=' | '.' | ';' | ':' | '_' | 'step' | 'while' | 'until' | 'comment'
	bracket = '(' | ')' | '[' | ']' | "'" | 'begin' | 'end'
	types = 'real' | 'integer' | 'Boolean'
	specificator = 'string' | 'label' | 'value'
	ct = 0
	beginct = 0	 ;*begin statements that haven't been closed yet	
;*Not all of those should be doing GETWORDS; you have to check for operators as well	
	
	DEFINE('IDENTIFIER(line)')
	DEFINE('NUMBER(line)')
	;*Description: Checks the symbol after a variable for a [ to determine whether to continue
	;* as an array or not.
	DEFINE('ARRAYSIGN(line)')
	DEFINE('BLOCK(line)')
	DEFINE('ARITHMETICEXP(line)')
	DEFINE('COMMENT(actualline)')
	DEFINE('DECLARATION(actualline)')
	DEFINE('PROCEDURE(actualline)')

NEXTL	originalline = input	:f(GOOD)S(GETSYMBOL)

;* Gets the individual words of the line
GETSYMBOL
	originalline (SPAN(letters digits) | ANY(symbols) | ' ') . symbol =	:f(NEXTL)
	IDENT(symbol,';')	:S(CHECK)
	IDENT(symbol,'begin')	:S(CHECKBL)
	actualline = actualline symbol	:(GETSYMBOL)

CHECK	DECLARATION(actualline)	:(GETSYMBOL)
CHECKBL	BLOCK(actualline)	:S(ISBLOCK)F(NOTBLOCK)

BLOCK	beginct = beginct + 1
	output = beginct
	LABEL = SPAN(letters ' ') ':'
	BLOCKBEG = LABEL (SPAN(' ') 'begin')
BLOCK0	originalline (SPAN(letters digits) | ANY(symbols) | ' ') . symbol =	:f(BLOCK01)
	IDENT(symbol,';')	:S(BLOCK02)
	actualline = actualline symbol	:(BLOCK0)
BLOCK01	originalline = input	:(BLOCK0)
BLOCK02	output = 'BLOCK02'
	DECLARATION(actualline)	;*:s(BLOCK03) must be begin <declaration>
	;*ASSIGNMENT(actualline)	:S(BLOCK03)
	;*GOTO(actuallines)	:S(BLOCK03)
	;*PROCEDUREDEC(actuallines)	:F(FRETURN)
BLOCK03	actualline = ''	:(BLOCK1)
BLOCK1	originalline (SPAN(letters digits) | ANY(symbols) | ' ') . symbol = :f(BLOCKNEW)
	IDENT(symbol,';')	:S(BLOCKCHK)
	IDENT(symbol,'begin')	:S(BLOCKCHK1)
	IDENT(symbol,'end')	:S(BLOCKEND)
	;*IDENT(symbol,LABEL)	:S(BLOCKCHK1)
	actualline = actualline symbol	:(BLOCK1)
BLOCKCHK	DECLARATION(actualline)	:(BLOCK1)
	
BLOCKCHK1	BLOCK(actualline)	:(BLOCK1)
	
BLOCKNEW	originalline = input	:f(FRETURN)S(BLOCK1)
BLOCKEND	beginct = beginct - 1
	LT(beginct,0)	:S(FRETURN)
	;*Check for type of exp before the 'end'
	actualline = ''	:(return)
		
	
ISBLOCK	output = "Found a block"	:(GETSYMBOL)

NOTBLOCK	output = "Not a block"	:(GETSYMBOL)



DECLARATION
	templine = actualline
DECLARTYPE
	OWN = ('own' | '') ' '
	TYPEDEC = OWN types
	templine TYPEDEC =	:s(return)f(DECLARARRAY) ;*on S, check list of items
DECLARARRAY
	templine = actualline
	ARRAYDEC = (TYPEDEC | '') 'array'
	templine ARRAYDEC =	:s(return)f(DECLARSWITCH)
DECLARSWITCH
	templine = actualline
	SWITCHDEC1 = 'switch' SPAN(' ')
	SWITCHDEC2 = SWITCHDEC1 SPAN(letters)
	SWITCHDEC3 = SWITCHDEC2 (SPAN(' ') ':=')
	templine SWITCHDEC3 =	:S(RETURN)F(freturn)	

BAD	output = 'No'	:(END)
GOOD	output = 'Yes'	:(END)

END
